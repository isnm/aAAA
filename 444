/*
 * Software License Agreement (BSD License)
 *
 * Copyright (c) 2017-2018, AUBO Robotics
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *       * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *       * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *       * Neither the name of the Southwest Research Institute, nor the names
 *       of its contributors may be used to endorse or promote products derived
 *       from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
#include "aubo_driver/aubo_driver.h"
#include "aubo_driver.cpp"
#include <sensor_msgs/Joy.h>
#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <aubo_msgs/JointPos.h>
#include <sensor_msgs/JointState.h>

#include <string>
#include <cstdlib>
#include <unistd.h>
#include <math.h>
#include <stdio.h>
#include <sstream>
#include <fstream>
using namespace aubo_driver;
double target1[6] = {0.0,0.0,0.0,0.0,0.0,45.0/180*M_PI};
double target2[6] = {0.0,0.0,0.0,0.0,0.0,-45.0/180*M_PI};
double currentjoint[6] = {0.0};
int state = 0;
int joystate =0;
void jointCallback(const sensor_msgs::JointState msg){
     ROS_INFO("%f,%f,%f,%f,%f,%f", msg.position[0],msg.position[1],msg.position[2],msg.position[3],msg.position[4],msg.position[5]);
     for(int i=0; i<6; i++) {
        currentjoint[i] = msg.position[i];
             
    }
	if(currentjoint[5]-(90.0/180*M_PI)<0.1/180*M_PI ){
		state = 1;
	}
	else if (currentjoint[5]-(-90.0/180*M_PI)<0.1/180*M_PI){
		state =0;	
	}
}

int main(int argc,char **argv)
{
  
  
	ros::init(argc, argv, "TestTeach");

	ros::NodeHandle n;


	AuboDriver robot_driver;


	/** If connect to a real robot, then you need initialize the dynamics parametersã€€**/
	aubo_robot_namespace::ROBOT_SERVICE_STATE result;
	//tool parameters
	aubo_robot_namespace::ToolDynamicsParam toolDynamicsParam;
	memset(&toolDynamicsParam, 0, sizeof(toolDynamicsParam));

	robot_driver.robot_send_service_.rootServiceRobotStartup(toolDynamicsParam/**tool dynamics paramters**/,
                                             6        /*collision class*/,
                                             true     /* Is allowed to read robot pose*/,
                                             true,    /*default */
                                             1000,    /*default */
                                             result); /*initialize*/

	ros::Rate loop_rate(10);
	while (ros::ok())
	{
		if(joystate ==0){
			if(state == 0)
			{
				robot_driver.robot_send_service_.robotServiceJointMove(target1, true); //+45 degree
			}
			else if(state == 1){
				robot_driver.robot_send_service_.robotServiceJointMove(target2, true);// -45 degree	
			}
		
			
		}
		else if (joystate ==1){
				robot_driver.robot_send_service_.ro
			
		}
	}
}

